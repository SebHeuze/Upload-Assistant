# Upload Assistant - C411 Tracker (Manual Upload)
# -*- coding: utf-8 -*-
import os
import re
import shutil
import unicodedata
from src.console import console
from src.trackers.COMMON import COMMON


class C411():
    def __init__(self, config):
        self.config = config
        self.tracker = 'C411'
        self.source_flag = 'C411'
        self.banned_groups = []

    def remove_accents(self, text):
        """Remove accents and special characters - Principe d'accentuation."""
        if not text:
            return text
        # Normalize unicode characters and remove accents
        nfkd = unicodedata.normalize('NFKD', text)
        return ''.join([c for c in nfkd if not unicodedata.combining(c)])

    def sanitize_filename(self, filename):
        """Remove or replace characters not allowed in Windows filenames."""
        # Windows forbidden characters: < > : " / \ | ? *
        forbidden_chars = '<>:"/\\|?*'
        for char in forbidden_chars:
            filename = filename.replace(char, '')
        # Remove any trailing dots or spaces
        filename = filename.rstrip('. ')
        return filename

    def build_c411_name(self, meta):
        """Build C411-compliant release name based on Upload Assistant name."""
        # Start with the name generated by Upload Assistant (already has correct format)
        base_name = meta.get('name', meta.get('uuid', ''))

        # Apply C411-specific transformations
        c411_name = base_name

        # Replace spaces with dots (Principe d'uniformit√© typographique)
        c411_name = c411_name.replace(' ', '.')

        # Replace DD+ with DDP (C411 prefers DDP notation)
        c411_name = c411_name.replace('DD+', 'DDP')
        c411_name = c411_name.replace('DD+.', 'DDP.')

        # Replace E-AC-3 variations with DDP
        c411_name = c411_name.replace('E-AC-3', 'DDP')
        c411_name = c411_name.replace('EAC3', 'DDP')

        # Replace HEVC with H265 if needed (keep H265 as is, convert HEVC)
        c411_name = c411_name.replace('HEVC', 'H265')

        # Remove accents (Principe d'accentuation)
        c411_name = self.remove_accents(c411_name)

        # Clean up colons that might cause filename issues
        c411_name = c411_name.replace(':.', '.')
        c411_name = c411_name.replace(':', '.')

        # Remove multiple consecutive dots
        c411_name = re.sub(r'\.+', '.', c411_name)

        return c411_name

    async def upload(self, meta, disctype):
        common = COMMON(config=self.config)

        # Build C411-compliant name
        c411_name = self.build_c411_name(meta)
        meta['c411_name'] = c411_name

        console.print(f"[cyan]C411 Release Name: {c411_name}")

        # Creates [C411].torrent with announce_url from config
        await common.create_torrent_for_upload(meta, self.tracker, self.source_flag)

        # Rename torrent file to use C411-compliant name with [C411] prefix
        default_torrent = f"{meta['base_dir']}/tmp/{meta['uuid']}/[C411].torrent"
        c411_filename = self.sanitize_filename(c411_name)
        c411_torrent = f"{meta['base_dir']}/tmp/{meta['uuid']}/[C411]{c411_filename}.torrent"
        if os.path.exists(default_torrent):
            shutil.move(default_torrent, c411_torrent)
            os.chmod(c411_torrent, 0o750)

        await self.edit_desc(meta)
        await self.create_nfo(meta)

        console.print(f"[green]C411 torrent created: tmp/{meta['uuid']}/[C411]{c411_filename}.torrent")
        console.print(f"[green]C411 description: tmp/{meta['uuid']}/[C411]DESCRIPTION.txt")
        console.print(f"[green]C411 NFO created: tmp/{meta['uuid']}/{c411_filename}.nfo")
        console.print("[yellow]Upload manually via C411 website")
        console.print(f"[yellow]Use release name: {c411_name}")
        return True

    async def edit_desc(self, meta):
        """Create C411-formatted description file."""
        desc_path = f"{meta['base_dir']}/tmp/{meta['uuid']}/[C411]DESCRIPTION.txt"
        with open(desc_path, 'w', encoding='utf-8') as desc:
            # Header info
            desc.write(f"[b]{meta['title']} ({meta['year']})[/b]\n\n")

            # Technical info
            if meta['is_disc'] == "DVD":
                res = meta['source']
            else:
                res = meta['resolution']
            desc.write(f"[b]Format:[/b] {res} / {meta['type']}\n\n")

            # Links
            desc.write("[b]Links:[/b]\n")
            if meta['tmdb'] != 0:
                desc.write(f"TMDB: https://www.themoviedb.org/{meta['category'].lower()}/{meta['tmdb']}\n")
            if meta['imdb_id'] != 0:
                desc.write(f"IMDb: https://www.imdb.com/title/tt{meta['imdb_id']}\n")

            # Overview
            if meta.get('overview'):
                desc.write(f"\n[b]Synopsis:[/b]\n{meta['overview']}\n")

            # Screenshots
            if meta.get('image_list'):
                desc.write("\n[b]Screenshots:[/b]\n")
                for img in meta['image_list']:
                    desc.write(f"[img]{img.get('raw_url', img.get('img_url'))}[/img]\n")

        # Set file permissions to 750
        os.chmod(desc_path, 0o750)

    async def create_nfo(self, meta):
        """Create NFO file from MEDIAINFO.txt with C411-compliant name."""
        mediainfo_path = f"{meta['base_dir']}/tmp/{meta['uuid']}/MEDIAINFO.txt"
        # Use the C411-compliant name that was already built
        c411_name = meta['c411_name']
        # Sanitize filename for Windows compatibility and use lowercase .nfo extension
        c411_filename = self.sanitize_filename(c411_name)
        nfo_path = f"{meta['base_dir']}/tmp/{meta['uuid']}/{c411_filename}.nfo"

        if os.path.exists(mediainfo_path):
            shutil.copy2(mediainfo_path, nfo_path)
            # Set file permissions to 750
            os.chmod(nfo_path, 0o750)
        else:
            console.print("[yellow]Warning: MEDIAINFO.txt not found, skipping NFO creation")

    async def search_existing(self, meta, disctype):
        """No API search - return empty list."""
        console.print("[yellow]C411 dupe check skipped (manual mode)")
        return []
